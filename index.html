<!DOCTYPE html>
<html>

<head>
    <title>Проект "Комменты"</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="styles.css" />
</head>

<body>
    <div class="container">
        <span class="alert">Подождите, пожалуйста, идёт загрузка данных!</span>
        <ul id="list" class="comments">
            <!-- Список рендерится из JS-->
        </ul>
        <div class="add-form">
            <input id="add-name" value="" type="text" class="add-form-name" placeholder="Введите ваше имя" />
            <textarea id="add-text" value="" type="textarea" class="add-form-text" placeholder="Введите ваш коментарий"
                rows="4"></textarea>
            <div class="add-form-row">
                <button id="button-add" class="add-form-button">Написать</button>
            </div>
        </div>
    </div>
</body>
<style>
    .error {
        background-color: orangered;
    }
</style>
<script>
    "use strict";
    const inputElement = document.getElementById('add-name');
    const textAreaElement = document.getElementById('add-text');
    const buttonElement = document.getElementById('button-add');
    const listElement = document.getElementById('list');
    const formatDateTime = (date) => {
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');  // счет месяцев начинается с 0, а не с единицы. Для корректного вывода нужно к числу прибавить единичку. 
        const year = String(date.getFullYear() - 2000);
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        return `${day}.${month}.${year} ${hours}:${minutes}`;
    };
    // Задание 2.12 - Асинхронность, API
    // Подключите приложение комментариев к API комментариев, в результате приложение должно 
    // получать список комментариев из API и добавлять новый комментарий через API.
    // Задание 2.13 - Цепочки промисов.
    // 1) переделайте все вызовы then на цепочки промисов, 
    // 2) вынесите код получения списка комментариев в отдельную функцию, 
    // 3) Используйте «замедление интернета» в консоли разработчика 
    //    на вкладке сеть, чтобы отладить работу лоадеров,
    // Результат: 1)  Я как пользователь при запуске приложения понимаю, 
    //                что данные загружаются и мне нужно немного подождать.
    //             2) Я как пользователь при добавлении комментария понимаю, 
    //                что мне нужно подождать и не могу случайно отправить коммент
    //                 повторно во время загрузки предыдущего.

    let studentsComments = [
        // {
        //     name: "Глеб Фокин",
        //     date: "12.02.22 12:18",
        //     text: "Это будет первый комментарий на этой странице",
        //     likes: 3,
        //     isLiked: true,
        // },
        // {
        //     name: "Варвара Н.",
        //     date: "13.02.22 19:22",
        //     text: "Мне нравится как оформлена эта страница! ❤",
        //     likes: 75,
        //     isLiked: false,
        // },
    ];
    // 2.13: 1) переделайте все вызовы then на цепочки промисов, 

    const fetchAndRenderComments = () => {

        return fetch("https://wedev-api.sky.pro/api/v1/elena-bersh/comments", {
            method: "GET",
        })
            .then((response) => {
                console.log(response);
                return response.json();
            })
            .then((responseData) => {
                console.log(responseData);
                let addComments = responseData.comments.map((comment) => {
                    return {
                        // Достаём имя автора
                        name: comment.author.name,
                        // Преобразуем дату-строку в Date
                        date: new Date(comment.date),
                        text: comment.text,
                        // date: currentDate.toLocaleString('ru-RU', options),
                        // date: formatDateTime(new Date()),
                        likes: comment.likes,
                        // в апи пока вообще нет признака лайкнутости
                        // поэтому пока добавляем заглушку
                        isLiked: false,
                    };

                });
                // добавим таймер при получении данных с сервера
                setTimeout(() => {
                    // обратимся по дереву к span в начале html-кода через его класс и к его css,
                    // где выключим отображение фразы, записанной в span
                    // Через style мы обращаемся к css
                    document.querySelector(".alert").style.display = 'none';
                    studentsComments = addComments;
                    console.log(addComments);
                    renderStudentsComments();
                }, 1000);
            });
    };
    fetchAndRenderComments();

    // Постановка лайков
    const initLikeListeners = () => {
        const likeButtons = document.querySelectorAll(".like-button");
        for (const likeButton of likeButtons) {
            likeButton.addEventListener('click', (event) => {
                event.stopPropagation();

                const index = likeButton.dataset.index;
                studentsComments[index].likes += studentsComments[index].isLiked ? -1 : +1;
                studentsComments[index].isLiked = !studentsComments[index].isLiked;

                renderStudentsComments();

            });
        };

    };
    // План ответа на комментарии
    // 1. (+) Мы храним список студентов в js массиве
    // 2. (+) При клике мы показываем  нужный элемент из массива в форме
    // 3. Мы добавляем в форму свой коммент на этот и отправляем в ленту, в новый массив
    // 4. (+) На основе нового массива в js формируем html разметку комментариев

    //Цитируем комментарий в форму
    const initAnswerComments = () => {
        const commentsElements = document.querySelectorAll(".comment");
        for (const commentsElement of commentsElements) {
            commentsElement.addEventListener("click", () => {
                const index = commentsElement.dataset.index;
                //console.log(index);
                const commentText = studentsComments[index].text;
                const commentAuthor = studentsComments[index].name;
                //console.log(commentText, commentAuthor);
                textAreaElement.value = `${commentText} > ${commentAuthor}`;


                renderStudentsComments();
            });
        };
    };

    // Рендер-функция отрисовывает новые комменты
    const renderStudentsComments = () => {

        const studentsHtml = studentsComments.map((comment, index) => {
            return `<li class="comment" data-index="${index}">
  <div class="comment-header">
    <div>${comment.name}</div>
    <div>${comment.date}</div>
  </div>
  <div class="comment-body">
    <div class="comment-text">
      ${comment.text}
    </div>
  </div>
  <div class="comment-footer">
    <div class="likes">
      <span class="likes-counter">${comment.likes}</span>
      <button class="like-button ${studentsComments[index].isLiked ? "-active-like" : ""}" data-index="${index}"></button>
    </div>
  </div>
</li>`;
        })
            .join("");
        // console.log(studentsHtml);
        listElement.innerHTML = studentsHtml;
        initLikeListeners();
        initAnswerComments();

    }
    renderStudentsComments();


    // Кнопка добавления комментов
    buttonElement.addEventListener("click", () => {
        // const currentDate = new Date();
        //const options = { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric' };
        // console.log(currentDate.toLocaleString('ru-RU', options));
        // Подсветка ошибочных комментариев
        inputElement.classList.remove("error");
        textAreaElement.classList.remove("error");

        if (inputElement.value === '') {
            // const newError = new Error("Не вводите пустую строку");
            // console.log(newError);
            // если он в переменной, то можно с ним работать в коде, отображать в интерфейсе.
            inputElement.classList.add("error");
            if (textAreaElement.value === '') {
                textAreaElement.classList.add("error");
                return;
            };
            return;
        };
        // const oldListHtml = listElement.innerHTML;

        //2.13 2) Я как пользователь при добавлении комментария понимаю, 
        //   что мне нужно подождать и не могу случайно отправить коммент
        //    повторно во время загрузки предыдущего.
        buttonElement.disabled = true;
        buttonElement.textContent = "Комментарий добавляется...";


        // 2.13: 1) переделайте все вызовы then на цепочки промисов, 

        studentsComments.push(
            fetch("https://wedev-api.sky.pro/api/v1/elena-bersh/comments", {
                method: "POST",
                body: JSON.stringify({
                    text: textAreaElement.value,
                    name: inputElement.value,
                }),
            })
                .then((response) => {
                    return response.json();
                })
                .then(() => {
                    buttonElement.disabled = false;
                    buttonElement.textContent = "Написать";
                    // 2.13: 2) вынесите код получения списка комментариев в отдельную функцию, 
                })
            // 2.13 2) Я как пользователь при добавлении комментария понимаю, 
            // что мне нужно подождать и не могу случайно отправить коммент
            // повторно во время загрузки предыдущего. Еле нашла, куда ставить кнопку!

        );

        fetchAndRenderComments();
        // renderStudentsComments();
        inputElement.value = '';
        textAreaElement.value = '';
    });


    //Ответы на комментарии. План:
    //1. При клике на комментарий в списке в форму подставляется текст комментария и имя автора комментария
    //2. Я могу ответить на этот текст в форме
    // Уязвимость «HTML-теги в имени автора и тексте комментария». План:
    //+ 1. Написать в поле «Ваше имя» HTML-разметку, например `<strong> Глеб </strong>`.
    //  +  2. Написать в поле «Ваше комментарий» HTML-разметку, например `<h1> Коммент </h1>`.
    //   + 3. Нажать на кнопку «Написать».
    // Код писать здесь
    // console.log("It works!");
    // А как добавить лоадер при загрузке приложения?
    // Можно создать переменную, которая будет хранить статус загрузки приложения.
    //  Можно вызвать рендер, и если переменная равна true, то можно показать этот лоадер.
    //  После первой загрузки комментариев нужно изменить значение переменной на противоположное.
    //  В функции получения комментариев снова вызывается рендер-функция — переменная уже будет
    //  все время с другим значением и на экране не появится до перезагрузки страницы.
</script>

</html>
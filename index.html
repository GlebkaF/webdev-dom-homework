<!DOCTYPE html>
<html>
  <head>
    <title>Проект "Комменты"</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="styles.css" />    
  </head>

  <body>
    <div class="container">
      <ul class="comments" id="list-comments">        
      </ul>
      <div id="message-pannel" class="message-pannel hidden"></div>
      <div id="control-pannel" class="control-pannel">
        <button class="remove-comment-button" id="button-remove-comment">Удалить последний коментарий</button>
        <div class="add-form">
          <input
            type="text"
            class="add-form-name"
            placeholder="Введите ваше имя"          
          />
          <textarea
            type="textarea"
            class="add-form-text"
            placeholder="Введите ваш коментарий"
            rows="4"
          ></textarea>
          <div class="add-form-row">
            <button class="add-form-button" id="button-add-comment">Написать</button>
          </div>
        </div>
      </div>
    </div>

    <script type="text/html" id="template-comment">
      <li class="comment">
        <div class="comment-header">
          <div>{author}</div>
          <div>{date}</div>
        </div>
        <div class="comment-body">
          <div class="comment-text">
            <pre>{comment}</pre>
          </div>
        </div>
        <div class="comment-footer">
          <div class="likes">
            <span class="likes-counter">0</span>
            <button class="like-button"></button>
          </div>
        </div>
      </li>
    </script>

  </body>

  <script>
    "use strict";
   

    let commentsData = [
      {
        author: "Глеб Фокин",
        date: "12.02.22 12:18",
        text: "Это будет первый комментарий на этой странице",
        likesCount: 3,
        isLiked: false,
        isEdited: false
      },
      {
        author: "Варвара Н.",
        date: "13.02.22 19:22",
        text: "Мне нравится как оформлена эта страница! ❤",
        likesCount: 75,
        isLiked: true,
        isEdited: false
      }
    ];

    const API_URL = 'https://wedev-api.sky.pro/api/v1/pogozhiyag/comments';

    const BEGIN_QUOTE_MARK = '::BEGIN_QUOTE::';
    const END_QUOTE_MARK = '::END_QUOTE::';

    const formAddComment = document.getElementsByClassName('add-form')[0];
    const inputName = formAddComment.getElementsByClassName('add-form-name')[0];
    const inputComment = formAddComment.getElementsByClassName('add-form-text')[0];
    const inputs = [inputName, inputComment];

    const listComments = document.getElementById('list-comments');
    const buttonAddComment = document.getElementById('button-add-comment');
    const templateComment = document.getElementById('template-comment');
    const messagePannel = document.getElementById('message-pannel');
    const controlPannel = document.getElementById('control-pannel');

    const buttonRemoveComment = document.getElementById('button-remove-comment');

    

    const startLongProcess = (message, process) => {
      messagePannel.textContent  = message;
      messagePannel.classList.remove('hidden');
      controlPannel.classList.add('hidden');
      
      process()
      .catch((error) => {
        console.log(error);
      })
      .finally(() => {
        messagePannel.classList.add('hidden');
        controlPannel.classList.remove('hidden');
      });
    }

    const loadCommentsData = () => {
      return fetch(API_URL)
      .then(response => response.json())
      .then(result => {
        commentsData = result.comments.map(item => ({
            id: item.id,
            author: item.author.name,
            date: formatDateTime(new Date(item.date)),
            text: item.text,
            isLiked: item.isLiked,
            likesCount: item.likes
        }));
      })
      .then(renderComments);
    };

    const delay = (interval = 300) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve();
        }, interval);
      });
    };

    const setButtonRemoveCommentEnabled = () => buttonRemoveComment.disabled = commentsData.length == 0;

    const initCommentsEventHandlers = () => {
      const likeButtons = document.querySelectorAll('.comment .like-button');
      for (const button of likeButtons) {
        button.addEventListener('click', (event) => {
          event.stopPropagation();

          button.classList.add('loading-like');

          delay(1500)
          .then(() => {
            const item = commentsData[event.target.dataset.index];
            item.likesCount += item.isLiked ? -1 : +1;
            item.isLiked = !item.isLiked;
          })
          .then(renderComments);
        });
      }

      const editButtons = document.querySelectorAll('.comment .comment-edit-button');
      for (const button of editButtons) {
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          const item = commentsData[event.target.dataset.index];
          item.isEdited = true;
          renderComments();
        });
      }

      const editSaveButtons = document.querySelectorAll('.comment .comment-edit-save-button');
      for (const button of editSaveButtons) {
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          const item = commentsData[event.target.dataset.index];
          const textArea = event.target.parentElement.querySelectorAll('.comment-text-edit')[0];          
          item.isEdited = false;
          item.text = endcodeSpecialSymbols(textArea.value);
          renderComments();
        });
      }

      const editCancelButtons = document.querySelectorAll('.comment .comment-edit-cancel-button');
      for (const button of editCancelButtons) {
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          const item = commentsData[event.target.dataset.index];
          item.isEdited = false;          
          renderComments();
        });
      }

      const commentElements = document.querySelectorAll('.comment');
      for (const commentElement of commentElements) {
        commentElement.addEventListener('click', (event) => {
          event.stopPropagation();
          const item = commentsData[event.currentTarget.dataset.index];
          if(item.isEdited){
            return;
          }
          inputComment.value = decodeSpecialSymbols(`${BEGIN_QUOTE_MARK} ${item.author}: ${item.text} ${END_QUOTE_MARK}`);
          validateComment();
        });
      }
      
    }

    const renderComments = () => {
      const renderCommentText = (comment, index) => {        
        if(comment.isEdited){
          return `<textarea class="comment-text-edit">${comment.text}</textarea>          
          <button data-index="${index}" class="add-form-button comment-edit-save-button">Сохранить</button>
          <button data-index="${index}" class="add-form-button comment-edit-cancel-button">Отмена</button>`;
        } 
        return `<div class="comment-text">${renderCommentBody(comment.text)}</div>        
          <button data-index="${index}" class="add-form-button comment-edit-button">Редактировать</button>`;
      };
      
      const renderCommentBody = (text) => text
          .replaceAll(BEGIN_QUOTE_MARK, '<div class="quote-block">')
          .replaceAll(END_QUOTE_MARK, '</div>');
      


      const commentsHTML = commentsData.map((comment, index) =>
          `<li class="comment" data-index="${index}">
            <div class="comment-header">
              <div>${comment.author}</div>
              <div>${comment.date}</div>
            </div>
            <div class="comment-body"> 
             ${renderCommentText(comment, index)}
            </div>
            <div class="comment-footer">
              <div class="likes">
                <span class="likes-counter">${comment.likesCount}</span>
                <button data-index="${index}" class="like-button ${comment.isLiked ? 'active-like' : ''}"></button>
              </div>
            </div>
          </li>`
        ).join('');

      listComments.innerHTML = commentsHTML;

      initCommentsEventHandlers();

      setButtonRemoveCommentEnabled();
    };



    const postComment = (name, text) => {
      const payload = {
        text: endcodeSpecialSymbols(text),
        name: endcodeSpecialSymbols(name)
      };

      return fetch(API_URL,{
        method: 'POST',
        body: JSON.stringify(payload)
      })
      .then(async response => {
        if(response.status !== 201){
          const responseJson = await response.json();
          console.log(responseJson.error);
        }
      })
      .finally(loadCommentsData);
    };


    const validationState = {
      isNameValid: false,
      setIsNameValid(state) { this.isNameValid = state; if(this.onchange) this.onchange(); },
      isCommentValid: false,
      setIsCommentValid(state) { this.isCommentValid = state; if(this.onchange) this.onchange(); },
      isValid(){
        return this.isNameValid && this.isCommentValid;
      }
    };

    const formatDateTime = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = String(date.getFullYear() - 2000);
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      return `${day}.${month}.${year} ${hours}:${minutes}`;
    };

    const endcodeSpecialSymbols = s =>
      s.replaceAll("&", "&amp;")
       .replaceAll("<", "&lt;")
       .replaceAll(">", "&gt;")
       .replaceAll('"', "&quot;");
    
    const decodeSpecialSymbols = s =>
      s.replaceAll("&amp;", "&")
       .replaceAll("&lt;", "<")
       .replaceAll("&gt;", ">")
       .replaceAll("&quot;", '"');
    

    const inputIsNotEmpty = (input) => input.value.trim() !== '';

    const validateName = () => { 
      validationState.setIsNameValid(inputIsNotEmpty(inputName)); 
      return validationState.isNameValid;
    };
    const validateComment = () => {
      validationState.setIsCommentValid(inputIsNotEmpty(inputComment)); 
      return validationState.isCommentValid;
    };

    const setAddCommentButtonEnabled = () => {
      buttonAddComment.disabled = !validationState.isValid();
    };

    const setInputValidityStatus = (input, status) =>{
      if(status){
        input.classList.remove('error');
      } else {
        input.classList.add('error');
      }
    };

    const validate = () => {      
      setInputValidityStatus(inputName, validateName());
      setInputValidityStatus(inputComment, validateComment());
      return validationState.isValid();
    }

    const validateAndSend = () => {      
      if(!validate()){
        return;
      }
      
      startLongProcess('Сообщение отправляется...', () => postComment(inputName.value, inputComment.value));      
      
      inputComment.value = '';
      validateComment();
    };

    const removeLastComment = () => {
      if(commentsData.length == 0){
        return;
      }
      commentsData.splice(commentsData.length - 1, 1);
      renderComments();
    }

    
    
    inputName.addEventListener('input', validateName);
    
    inputComment.addEventListener('input', validateComment);
    
    buttonAddComment.addEventListener('click', validateAndSend);

    validationState.onchange = () => setAddCommentButtonEnabled();

    buttonRemoveComment.addEventListener('click', removeLastComment);



    startLongProcess('Сообщения загружаются...', loadCommentsData);
    validateName();
    validateComment();
    setButtonRemoveCommentEnabled();
  </script>
</html>
